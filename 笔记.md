# JUC多线程及并发包

## 一、ArrayList相关

### **1. new ArrayList<>();究竟是创建了什么？**

在<>中填入了什么就是创建了什么，从源码来看，就是创建了一个空的list，初始值为10。

![image-20200716184002206](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200716184002206.png)

### **2. ArrayList扩容问题：**

首先是通过add()方法添加元素，在初始容量满了之后，会进入到add方法里的ensureCapacityInternal(size + 1);首先是计数器modCount++，然后判断minCapacity - elementData.length > 0，即初始容量减去已添加的长度是否大于0，如果大于0，进入grow(minCapacity)方法，int newCapacity = oldCapacity + (oldCapacity >> 1);通过Arrays.copyOf(elementData, newCapacity)将其扩容到1.5倍。

![add方法](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200716184339467.png)

![ensureExplicitCapacity方法](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200716184602057.png)

![grow方法](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200716184838865.png)

![copyOf方法](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200716184929188.png)

### **3. ArrayList线程不安全的例子**

ArrayList线程不安全，add()方法写操作的时候，为了保证并发性和效率，没有加Synchronized锁。

#### 	**3.1 集合类不安全之并发修改异常**

![并发修改异常ConcurrentModificationException](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200716224207999.png)

解决方法：

1、new Vector();

vector内部加了Synchronized，可以保证数据一致性，但是并发性急剧下降，他在jdk1.0就有了，ArrayList产生在jdk1.2，是为了并发而生。

2、Collections.synchronizedList(new ArrayList<>());

3、new CopyOnWriteArrayList<>(); ------ **集合类不安全之写时复制**

![写时复制](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200716225728034.png)

#### 	**3.2 集合类不安全之Set**

![并发修改异常](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200716231746274.png)

解决方法：

1、Collections.synchronizedSet(new HashSet<>());

2、new CopyOnWriteArraySet<>();其实他的底层也是CopyOnWriteArrayList

![CopyOnWriteArraySet底层](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200717094311985.png)

HashSet的底层是什么？HashMap

![HashSet底层数据结构](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200717095144083.png)

既然HashSet的底层是HashMap，那为什么HashSet的add方法填入一个值，而HashMap的add方法需要(K, V)键值对两个值？

首先HashSet中的add方法其实就是HashMap中的put方法的key，value是一个叫PRESENT的Object类型的常量，所以可以这么说：HashSet的add方法只关心key，value是恒定的常量PRESENT。

![HashSet的add方法](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200717100033035.png)

![PRESENT常量](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200717100113457.png)

#### 	**3.3 集合类不安全之Map**

![并发修改异常](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200717100712672.png)

解决方法：

1、new ConcurrentHashMap<>();

![ConcurrentHashMap](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200717101347108.png)

2、Collections.synchronizedMap(new HashMap<>());

## 二、Java锁相关

### 1. 公平和非公平锁

```java
Lock lock = new ReentrantLock();
```

![非公平锁](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200717114040029.png)

```java
Lock lock = new ReentrantLock(true);
```

![公平锁](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200717114207706.png)

#### 1.1 公平锁/非公平锁是什么？

公平锁：

​		是指多个线程按照申请锁的顺序来获取锁。类似排队打饭，先来后到。

非公平锁：
		是指在多线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取到锁，在高并发的情况下，有可能造成优先级反转或者饥饿现象。

#### 1.2 区别

公平锁/非公平锁：并发包ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁。

关于两者区别：
**公平锁：**Threads acquire a fair lock in the order in which they requested it.
公平锁，就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FFO的规则从队列中取到自己

**非公平锁：**a nonfair lock permits barging:threads requesting a lock can jump ahead of the queue of waiting threads if the lock appens to be available when it is requested.
非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。

**Java中对于ReentrantLock而言，通过构造哈数指定该锁是否是公平锁，默认是非公平锁，非公平锁的优点在于吞吐量必公平锁大。对于synchronized而言，也是一种非公平锁。**

### 2. 可重入锁（也叫做递归锁）

#### 2.1 什么是可重入锁

指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，也即是说，**线程可以进入任何一个它已经拥有的锁所同步着的代码块**。

#### 2.2 作用

可重入锁最大的作用是**避免死锁**。

### 3. 自旋锁

#### 3.1 什么是自旋锁

是指尝试获取锁的线程不会立即阻塞，而是**采用循环的方式去尝试获取锁**，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

### 4. 独占锁（写）/ 共享锁（读）/互斥锁

#### 4.1 定义

**独占锁：**指该锁一次只能被一个线程所持有。对 Reentrantlock 和 Synchronized 而言都是独占锁。是写锁，例如老师用红蜘蛛软件上课，只能写

**共享锁：**指该锁可被多个线程所持有。是读锁，例如学生用红蜘蛛软件听课，只能读
对ReentrantReadWriteLock，其读锁是共享锁，其写锁是独占锁。
读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。

####  4.2 手写自旋锁

```java
package com.aeliter.study.lock;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;

// 资源类
class MyCache {

    private volatile Map<String, Object> map= new HashMap<>();
    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    // 1. 写
    public void put(String key, Object value) {
        // 读写锁
        readWriteLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t 正在写入：" + key);
            // 模拟网络延时拥堵
            try { TimeUnit.MICROSECONDS.sleep(300); } catch(InterruptedException e) { e.printStackTrace(); }
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + "\t 写入完成：");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.writeLock().unlock();
        }
    }

    // 2. 读
    public void get(String key) {
        readWriteLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t 正在读取：");
            // 模拟网络延时拥堵
            try { TimeUnit.MICROSECONDS.sleep(300); } catch(InterruptedException e) { e.printStackTrace(); }
            Object result = map.get(key);
            System.out.println(Thread.currentThread().getName() + "\t 读取完成：" + result);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.readLock().unlock();
        }
    }

    // 3. 缓存清空
    public void clearMap() {
        map.clear();
    }

}
/**
 * @description: 读写锁
 * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。
 * 但是
 * 如果有一个线程想去写共享资源类，就不应该有其他线程可以对资源进行读或写
 *
 * 小总结:
 *      读-读能共存
 *      读-写不能共存
 *      写-写不能共存
 *
 *      写操作：原子+独占，整个过程必须是一个完整的统一体，中间不允许被分割、被打断。
 * @author: caibingqiang
 * @date: 2020-07-18 7:47
 * @version: V1.0
 */
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        // 线程操作资源类
        MyCache myCache = new MyCache();

        // 写操作
        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                myCache.put(tempInt + "", tempInt + "");
            }, String.valueOf(i)).start();
        }

        // 读操作
        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                myCache.get(tempInt + "");
            }, String.valueOf(i)).start();
        }
    }
}
```

运行结果：

```java
2	 正在写入：2
2	 写入完成：
1	 正在写入：1
1	 写入完成：
3	 正在写入：3
3	 写入完成：
4	 正在写入：4
4	 写入完成：
5	 正在写入：5
5	 写入完成：
1	 正在读取：
2	 正在读取：
4	 正在读取：
3	 正在读取：
5	 正在读取：
2	 读取完成：2
1	 读取完成：1
5	 读取完成：5
4	 读取完成：4
3	 读取完成：3
```



## 三、CountDownLatch/CyclicBarrier/Semaphore

### 1. CountDownLatch（秦灭六国，统一华夏，做减法）

#### 1.1 定义

让一些线程阻塞直到另外一些完成后才被唤醒

#### 1.2 使用

CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，调用线程会被阻塞，其他线程调用countDown方法计数器减1(调用countDown方法时线程不会阻塞)，当计数器的值变为0，因调用await方法被阻塞的线程会被唤醒，继续执行

#### 1.3 代码实现

```java
package com.aeliter.study.lock;

import com.aeliter.study.enums.CountryEnum;

import java.util.concurrent.CountDownLatch;

/**
 * @description: CountDownLatch
 * @author: caibingqiang
 * @date: 2020-07-18 9:32
 * @version: V1.0
 */
public class CountDownLatchDemo {

    public static void main(String[] args) throws InterruptedException {

        CountDownLatch countDownLatch = new CountDownLatch(6);
        for (int i = 1; i <= 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "\t 国，被灭！");
                countDownLatch.countDown();
            }, CountryEnum.forEach_CountryEnum(i).getRetMessage()).start();
        }

        countDownLatch.await();
        System.out.println(Thread.currentThread().getName() + "\t ######秦帝国，一统华夏！");
        System.out.println();
        System.out.println(CountryEnum.ONE);
        System.out.println(CountryEnum.ONE.getRetCode());
        System.out.println(CountryEnum.ONE.getRetMessage());

    }

    public static void closeDoor() throws InterruptedException {

        CountDownLatch countDownLatch = new CountDownLatch(6);

        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "\t 上完自习，离开教室");
                countDownLatch.countDown();
            }, String.valueOf(i)).start();
        }

        countDownLatch.await();
        System.out.println(Thread.currentThread().getName() + "\t ######班长最后关门走人");
    }

}
```

```java
package com.aeliter.study.enums;

import lombok.Getter;

/**
 * @description:
 * @author: caibingqiang
 * @date: 2020-07-18 9:49
 * @version: V1.0
 */
public enum CountryEnum {
    ONE(1, "齐"),

    TWO(2, "楚"),

    THREE(3, "燕"),

    FOUR(4, "赵"),

    FIVE(5, "魏"),

    SIX(6, "韩");

    @Getter private Integer retCode;
    @Getter private String retMessage;

    CountryEnum(Integer retCode, String retMessage) {
        this.retCode = retCode;
        this.retMessage = retMessage;
    }

    public static CountryEnum forEach_CountryEnum(int index) {
        CountryEnum[] myArray = CountryEnum.values();
        for (CountryEnum element : myArray) {
            if (index == element.getRetCode()) {
                return element;
            }
        }
        return null;
    }
}

```

运行结果：

```java
齐	 国，被灭！
楚	 国，被灭！
燕	 国，被灭！
赵	 国，被灭！
魏	 国，被灭！
韩	 国，被灭！
main	 ######秦帝国，一统华夏！
```

### 2. CyclicBarrier（集齐七颗龙珠即可召唤神龙，做加法）

#### 2.1 定义及使用

CyclicBarrier的字面意思是可循环(Cyclic)使用的屏障(barrier)，它要做的事情是,让一组线程到达一个屏障(也可以叫做同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。

#### 2.2 代码实现

```java
package com.aeliter.study.lock;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/**
 * @description: CyclicBarrier
 * @author: caibingqiang
 * @date: 2020-07-18 13:37
 * @version: V1.0
 */
public class CyclicBarrierDemo {

    public static void main(String[] args) {
        // CyclicBarrier(int parties, Runnable barrierAction)
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
            System.out.println(Thread.currentThread().getName() + "\t ######召唤神龙！");
        });

        for (int i = 1; i <= 7; i++) {
            final int tempInt = i;
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "\t 收集到第：" + tempInt + "颗龙珠");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }, String.valueOf(i)).start();
        }
    }

}
```

运行结果：

```java
1	 收集到第：1颗龙珠
2	 收集到第：2颗龙珠
4	 收集到第：4颗龙珠
3	 收集到第：3颗龙珠
5	 收集到第：5颗龙珠
6	 收集到第：6颗龙珠
7	 收集到第：7颗龙珠
7	 ######召唤神龙！
```

### 3. Semaphore（抢车位，可复用）

#### 3.1 定义

信号量的主要用户两个目的，一个是用于多和共享资源的相互排斥使用，另一个用于并发资源数的控制。

#### 3.2 代码实现

```java
package com.aeliter.study.lock;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * @description: Semaphore
 * @author: caibingqiang
 * @date: 2020-07-18 13:49
 * @version: V1.0
 */
public class SemaphoreDemo {

    public static void main(String[] args) {
        // Semaphore(int permits, boolean fair)
        Semaphore semaphore = new Semaphore(3); // 模拟三个停车位

        for (int i = 1; i <= 6; i++) { // 模拟六部汽车
            new Thread(() -> {
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + "\t 抢到车位");
                    // 暂停一会儿线程
                    try { TimeUnit.SECONDS.sleep(3); } catch(InterruptedException e) { e.printStackTrace(); }
                    System.out.println(Thread.currentThread().getName() + "\t 停车3秒后离开车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();// 释放停车位
                }
            }, String.valueOf(i)).start();
        }
    }

}

```

运行结果：

```java
1	 抢到车位
3	 抢到车位
2	 抢到车位
2	 停车3秒后离开车位
1	 停车3秒后离开车位
3	 停车3秒后离开车位
5	 抢到车位
4	 抢到车位
6	 抢到车位
5	 停车3秒后离开车位
4	 停车3秒后离开车位
6	 停车3秒后离开车位
```

## 四、阻塞队列

### 1. 定义

阻塞队列，顾名思义，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如图所示：
![image-20200718201216971](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200718201216971.png)
                                                线程1往阻塞队列中添加元素，而线程2从队列中移除元素

当阻塞队列是空时，从队列中**获取**元素的操作将会被阻塞。
当阻塞队列是满时，往队列中**添加**元素的操作将会被阻塞。

试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。
同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程从队列中移除一个或者多个元素或者完全清空队列后使队列重新变得空闲起来并后续新增。

### 2. 为什么用？有什么好处？

在多线程领域：所谓阻塞，在某些情况下会**挂起**线程(即阻塞)，一旦条件满足，被挂起的线程又会被自动**被唤醒**

为什么需要BlockingQueue
好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为BlockingQueue都给你一手包办了

在concurrent包发布以前，在多线程环境下，**我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全**，而这会给我们的程序带来不小的复杂度。

### 3. BlockingQueue的核心方法

![核心方法](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200718203424437.png)

| 抛出异常     | 当阻塞队列满时，再往队列里面add插入元素会抛IllegalStateException: Queue full<br/>当阻塞队列空时，再往队列Remove元素时候回抛出NoSuchElementException |
| ------------ | ------------------------------------------------------------ |
| **特殊值**   | **插入方法，成功返回true 失败返回false<br/>移除方法，成功返回元素，队列里面没有就返回null** |
| **一直阻塞** | **当阻塞队列满时，生产者继续往队列里面put元素，队列会一直阻塞直到put数据or响应中断退出<br/>当阻塞队列空时，消费者试图从队列take元素，队列会一直阻塞消费者线程直到队列可用** |
| **超时退出** | **当阻塞队列满时，队列会阻塞生产者线程一定时间，超过后限时后生产者线程就会退出** |

```java
package com.aeliter.study.thread;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * @description:阻塞队列
 * ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。
 * LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO（先进先出）排序元素，吞吐量要高于ArrayBlockingQueue。
 * SynchronousQueue：一个基于一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue。
 *
 * 1、队列
 * 2、阻塞队列
 *      2.1 阻塞队列有没有好的一面
 *
 *      2.2 不得不阻塞，你如何管理
 *
 * @author: caibingqiang
 * @date: 2020-07-18 14:55
 * @version: V1.0
 */
public class BlockingQueueDemo {

    public static void main(String[] args) throws InterruptedException {
//        List list = new ArrayList();
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        /**
         * 第一组：抛出异常
         * add(e)
         * remove()
         * element()
         */
        /*System.out.println(blockingQueue.add("a"));
        System.out.println(blockingQueue.add("b"));
        System.out.println(blockingQueue.add("c"));
//        System.out.println(blockingQueue.add("x")); // Exception in thread "main" java.lang.IllegalStateException: Queue full

        System.out.println(blockingQueue.element()); // 检查是否为空并且拿出队首元素

        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
//        System.out.println(blockingQueue.remove()); // Exception in thread "main" java.util.NoSuchElementException*/

        /**
         * 第二组：特殊值
         * offer(e)
         * poll()
         * peek()
         */
        /*System.out.println(blockingQueue.offer("a"));
        System.out.println(blockingQueue.offer("b"));
        System.out.println(blockingQueue.offer("c"));
//        System.out.println(blockingQueue.offer("x")); // false

        System.out.println(blockingQueue.peek()); // 检查是否为空并且拿出队列顶端元素

        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
//        System.out.println(blockingQueue.poll()); // null*/

        /**
         * 第三组：阻塞
         * put(e)
         * take()
         */
        /*blockingQueue.put("a");
        blockingQueue.put("b");
        blockingQueue.put("c");
        System.out.println("==============================");
//        blockingQueue.put("x"); // 一直等待

        blockingQueue.take();
        blockingQueue.take();
        blockingQueue.take();
        blockingQueue.take(); // 一直等待*/

        /**
         * 第四组：超时
         * offer(e, time, unit)
         * poll(time, unit)
         */
        System.out.println(blockingQueue.offer("a", 2L, TimeUnit.SECONDS));
        System.out.println(blockingQueue.offer("b", 2L, TimeUnit.SECONDS));
        System.out.println(blockingQueue.offer("c", 2L, TimeUnit.SECONDS));
//        System.out.println(blockingQueue.offer("d", 2L, TimeUnit.SECONDS)); // 2s之后，返回false

        System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));
        System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));
        System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));
        System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS)); // 2s之后，返回null

    }

}
```



### 4. 架构梳理 + 种类分析

#### 4.1 架构介绍

#### ![架构介绍](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200718202454803.png)4.2 种类分析

**ArrayBlockingQueue: 由数组结构组成的有界阻塞队列。**

**LinkedBlockingDeque: 由链表结构组成的有界(但大小默认值Integer.MAX_VALUE 2147483647 )阻塞队列。**

PriorityBlockingQueue：支持优先级排序的无界阻塞队列。

DelayQueue: 使用优先级队列实现的延迟无界阻塞队列。

**SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。**

```java
package com.aeliter.study.thread;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

/**
 * @description: SynchronousQueue
 * @author: caibingqiang
 * @date: 2020-07-18 22:00
 * @version: V1.0
 */
public class SynchronousQueueDemo {

    public static void main(String[] args) {

        BlockingQueue<String> blockingQueue = new SynchronousQueue<>();
        new Thread(() -> {
            try {
                System.out.println(Thread.currentThread().getName() + "\t put 1");
                blockingQueue.put("1");
                System.out.println(Thread.currentThread().getName() + "\t put 2");
                blockingQueue.put("2");
                System.out.println(Thread.currentThread().getName() + "\t put 3");
                blockingQueue.put("3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "AAA").start();

        new Thread(() -> {
            try {
                // 暂停一会儿线程
                try { TimeUnit.SECONDS.sleep(5); } catch(InterruptedException e) { e.printStackTrace(); }
                System.out.println(Thread.currentThread().getName() + "\t" + blockingQueue.take());

                try { TimeUnit.SECONDS.sleep(5); } catch(InterruptedException e) { e.printStackTrace(); }
                System.out.println(Thread.currentThread().getName() + "\t" + blockingQueue.take());

                try { TimeUnit.SECONDS.sleep(5); } catch(InterruptedException e) { e.printStackTrace(); }
                System.out.println(Thread.currentThread().getName() + "\t" + blockingQueue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "BBB").start();

    }

}
```

运行结果：

```java
AAA	 put 1
BBB	1
AAA	 put 2
BBB	2
AAA	 put 3
BBB	3
```

LinkedTransferQueue：由链表结构组成的无界阻塞队列。

LinkedBlockingDeque：由了解结构组成的双向阻塞队列。

#### 4.3 用在哪里

（1）生产者消费者模式

​	① 线程通信之生产者消费者传统版

```java
package com.aeliter.study.thread;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/** 资源类 */
class ShareData {

    private int number = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    /**
     * 加操作
     */
    public void increment() throws Exception {

        lock.lock();
        try {
            // 1、判断
            while (number != 0) {
                // 等待，不能生产
                condition.await();
            }
            // 2、干活
            number++;
            System.out.println(Thread.currentThread().getName() + "\t" + number);
            // 3、通知唤醒
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    /**
     * 减操作
     */
    public void decrement() throws Exception {

        lock.lock();
        try {
            // 1、判断
            while (number == 0) {
                // 等待，不能生产
                condition.await();
            }
            // 2、干活
            number--;
            System.out.println(Thread.currentThread().getName() + "\t" + number);
            // 3、通知唤醒
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

}
/**
 * @description:
 *
 * 题目：一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮
 *
 * 1、线程 操作（方法） 资源类
 * 2、判断 干活 唤醒通知
 * 3、防止虚假唤醒机制
 * @author: caibingqiang
 * @date: 2020-07-18 22:20
 * @version: V1.0
 */
public class ProdConsumer_TraditionDemo {

    public static void main(String[] args) {

        ShareData shareData = new ShareData();

        /**
         * AA 线程生产
         */
        new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                try {
                    shareData.increment();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }, "AA").start();

        /**
         * BB 线程消费
         */
        new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                try {
                    shareData.decrement();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }, "BB").start();

    }

}
```

运行结果：

```java
AA	1
BB	0
AA	1
BB	0
AA	1
BB	0
AA	1
BB	0
AA	1
BB	0
```

​	② 线程通信之生产者消费者阻塞队列版

```java
package com.aeliter.study.blockingqueue;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 资源类
 */
class MyResource {

    private volatile boolean FLAG = true; // 默认开启，进行生产 + 消费
    private AtomicInteger atomicInteger = new AtomicInteger(); // 默认值为0

    BlockingQueue<String> blockingQueue = null;

    public MyResource(BlockingQueue<String> blockingQueue) {
        this.blockingQueue = blockingQueue;
        System.out.println(blockingQueue.getClass().getName()); // 反射打印类名、包名
    }

    /**
     * 生产者
     * @throws Exception
     */
    public void myProduct() throws Exception {
        String data = null;
        boolean retValue;
        while (FLAG) {
            data = atomicInteger.incrementAndGet() + "";
            retValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);
            if (retValue) {
                System.out.println(Thread.currentThread().getName() + "\t 插入队列" + data + "成功");
            } else {
                System.out.println(Thread.currentThread().getName() + "\t 插入队列" + data + "失败");
            }
            TimeUnit.SECONDS.sleep(1);
        }
        System.out.println(Thread.currentThread().getName() + "\t 大老板叫停了，表示FLAG=false，生产动作结束");
    }

    /**
     * 消费者
     * @throws Exception
     */
    public void myConsumer() throws Exception {
        String result = null;
        while (FLAG) {
            result = blockingQueue.poll(2L, TimeUnit.SECONDS);

            if (null == result || result.equalsIgnoreCase("")) {
                FLAG = false;
                System.out.println(Thread.currentThread().getName() + "\t 超过2秒钟没有取到蛋糕，消费退出");
                System.out.println();
                System.out.println();
                return;
            }

            System.out.println(Thread.currentThread().getName() + "\t 消费队列蛋糕" + result + "成功");
        }
    }

    /**
     * 大老板叫停
     */
    public void stop() throws Exception {
        this.FLAG = false;
    }
}
/**
 * @description:
 *
 * volatile / CAS / AtomicInteger / BlockingQueue / 线程交互 / 原子引用
 *
 * @author: caibingqiang
 * @date: 2020-07-19 11:30
 * @version: V1.0
 */
public class ProdConsumer_BlockingQueueDemo {

    public static void main(String[] args) throws Exception {
        MyResource myResource = new MyResource(new ArrayBlockingQueue<>(10));
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "\t 生产线程启动");
            try {
                myResource.myProduct();
                System.out.println();
                System.out.println();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "Product").start();

        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "\t 生产线程启动");
            try {
                myResource.myConsumer();
                System.out.println();
                System.out.println();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "Consumer").start();

        // 暂停一会儿线程
        try { TimeUnit.SECONDS.sleep(5); } catch(InterruptedException e) { e.printStackTrace(); }
        System.out.println();
        System.out.println();
        System.out.println();

        System.out.println("5秒钟时间到，大老板main叫停，活动结束");

        myResource.stop();
    }

}
```

运行结果：

```java
java.util.concurrent.ArrayBlockingQueue
Product	 生产线程启动
Consumer	 生产线程启动
Product	 插入队列1成功
Consumer	 消费队列蛋糕1成功
Product	 插入队列2成功
Consumer	 消费队列蛋糕2成功
Product	 插入队列3成功
Consumer	 消费队列蛋糕3成功
Product	 插入队列4成功
Consumer	 消费队列蛋糕4成功
Product	 插入队列5成功
Consumer	 消费队列蛋糕5成功



5秒钟时间到，大老板main叫停，活动结束
Product	 大老板叫停了，表示FLAG=false，生产动作结束


Consumer	 超过2秒钟没有取到蛋糕，消费退出
```



（2）线程池

（3）消息中间件

## 五、Synchronized和lock有什么区别？用新的lock有什么好处？举例说说

### 1. 原始构造

- Synchronized是关键字，属于JVM层面，

  monitorenter（底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象只有在同步代码块或方法中才能调wait/notify等方法）

  monitorexit

- Lock是具体类（java.util.concurrent.lock），是api层面的锁，是Java 5之后的类

### 2. 使用方法

- Synchronized不需要用户去手动释放锁，当Synchronized代码执行完后系统会自动让线程释放对锁的占用

- ReentrantLock则需要用户去手动释放锁，若没有主动释放锁，就有可能导致出现死锁的现象，需要lock()和unlock()方法配合try/finally语句块来完成。

### 3. 等待是否可中断

- Synchronized不可中断，除非抛出异常或者正常运行完成

- ReentrantLock可中断，1. 设置超时方法trylock(long timeout, TimeUnit unit) 2. lockInterruptibly()代码块中，调用interrupt()方法可中断

### 4. 加锁是否公平

- Synchronized非公平锁

- ReentrantLock两者都可以，默认非公平锁，构造方法可以传入boolean值，true为公平锁，false为非公平锁

### 5. 锁绑定多个条件Condition

- Synchronized没有

- ReentrantLock用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像Synchronized要么随机唤醒一个线程要么唤醒全部线程。

### 题目：多线程之间按顺序调用，实现A -> B -> C三个线程启动，要求如下：

AA 打印5次，BB 打印10次，CC 打印15次，紧接着AA 打印5次，BB 打印10次，CC 打印15次，......，来10轮

```java
package com.aeliter.study.thread;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @description:
 *
 * 题目：Synchronized和lock有什么区别？用新的lock有什么好处？举例说说
 *
 * 1 原始构造
 *  Synchronized是关键字，属于JVM层面，
 *      monitorenter（底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象只有在同步代码块或方法中才能调wait/notify等方法）
 *      monitorexit
 *  Lock是具体类（java.util.concurrent.lock），是api层面的锁，是Java 5之后的类
 *
 * 2 使用方法
 *  Synchronized不需要用户去手动释放锁，当Synchronized代码执行完后系统会自动让线程释放对锁的占用
 *  ReentrantLock则需要用户去手动释放锁，若没有主动释放锁，就有可能导致出现死锁的现象，
 *  需要lock()和unlock()方法配合try/finally语句块来完成。
 *
 * 3 等待是否可中断
 *  Synchronized不可中断，除非抛出异常或者正常运行完成
 *  ReentrantLock可中断，1. 设置超时方法trylock(long timeout, TimeUnit unit)
 *                     2. lockInterruptibly()代码块中，调用interrupt()方法可中断
 *
 * 4 加锁是否公平
 *  Synchronized非公平锁
 *  ReentrantLock两者都可以，默认非公平锁，构造方法可以传入boolean值，true为公平锁，false为非公平锁
 *
 * 5 锁绑定多个条件Condition
 *  Synchronized没有
 *  ReentrantLock用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像Synchronized要么随机唤醒一个线程要么唤醒全部线程。
 *
 * 题目：多线程之间按顺序调用，实现A -> B -> C三个线程启动，要求如下：
 * AA 打印5次，BB 打印10次，CC 打印15次
 * 紧接着
 * AA 打印5次，BB 打印10次，CC 打印15次
 * ......
 * 来10轮
 *
 * @author: caibingqiang
 * @date: 2020-07-19 9:05
 * @version: V1.0
 */
class ShareResource {

    private int number = 1; // A: 1, B: 2, C: 3
    private Lock lock = new ReentrantLock();
    private Condition c1 = lock.newCondition();
    private Condition c2 = lock.newCondition();
    private Condition c3 = lock.newCondition();

    public void print5() {
        lock.lock();
        try {
            // 1.判断
            while (number != 1) {
                c1.await();
            }
            // 2.干活
            for (int i = 1; i <= 5; i++) {
                System.out.println(Thread.currentThread().getName() + "\t" + i);
            }
            // 3.通知（唤醒）
            number = 2; // 修改标志位
            c2.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void print10() {
        lock.lock();
        try {
            // 1.判断
            while (number != 2) {
                c2.await();
            }
            // 2.干活
            for (int i = 1; i <= 10; i++) {
                System.out.println(Thread.currentThread().getName() + "\t" + i);
            }
            // 3.通知（唤醒）
            number = 3; // 修改标志位
            c3.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void print15() {
        lock.lock();
        try {
            // 1.判断
            while (number != 3) {
                c3.await();
            }
            // 2.干活
            for (int i = 1; i <= 15; i++) {
                System.out.println(Thread.currentThread().getName() + "\t" + i);
            }
            // 3.通知（唤醒）
            number = 1; // 修改标志位
            c1.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

}
public class SyncAndReentrantLockDemo {

    public static void main(String[] args) {

        ShareResource shareResource = new ShareResource();

        new Thread(() -> {
            for (int i = 0; i <= 10; i++) {
                shareResource.print5();
            }
        }, "AA").start();

        new Thread(() -> {
            for (int i = 0; i <= 10; i++) {
                shareResource.print10();
            }
        }, "BB").start();

        new Thread(() -> {
            for (int i = 0; i <= 10; i++) {
                shareResource.print15();
            }
        }, "CC").start();

    }

}
```

## 六、线程池用过吗？ThreadPoolExecutor谈谈你的理解？

### 1. 为什么使用线程池？有什么优势

线程池做的工作主要是控制运行的线程的数量，**处理过程中将任务加入队列**，然后在线程创建后启动这些任务，**如果线程超过了最大数量，超出的数量的线程排队等候**，等其他线程执行完毕，再从队列中取出任务来执行。

他的主要特点为：**线程复用、控制最大并发数、管理线程**。

第一：降低资源消耗。通过重复利用自己创建的线程降低线程创建和销毁造成的消耗。
第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
第三：提高线程的可管理性。线程是稀缺资源，如果无限的创建，不仅会消耗资源，还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。

### 2. 线程池如何使用

#### 2.1 架构实现

Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类。

![架构](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200721091823273.png)



#### 2.2 编码实现

（1）Executors.newFixedThreadPool(int) 执行一个长期的任务，性能好很多

![Executors.newFixedThreadPool(int)](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200721094607185.png)

​	主要特点如下：
1. 创建一个**定长线程池**，可控制线程的最大并发数，超出的线程会在队列中等待。
2. newFixedThreadPool创建的线程池corePoolSize和MaxmumPoolSize是相等的，它**使用的LinkedBlockingQueue**。

（2）Executors.newSingleThreadExecutor() 一个任务一个线程执行的任务场景

![Executors.newSingleThreadExecutor() ](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200721094653952.png)

​	主要特点如下：
1. 创建一个**单线程化的线程池**，它只会用唯一的工作线程来执行任务，保证所有任务都按照指定顺序执行。
2. newSingleThreadExecutor将corePoolSize和MaxmumPoolSize都设置为1，它**使用的LinkedBlockingQueue**。

（3）Executors.newCachedThreadPool() 适用：执行很多短期异步的小程序或者负载较轻的服务器

![Executors.newCachedThreadPool() ](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200721094757139.png)

​	主要特点如下：
1. 创建一个**可缓存线程池**，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则创建新线程。
2. newCachedThreadPool将corePoolSize设置为0，MaxmumPoolSize设置为Integer.MAX_VALUE，它**使用的是SynchronousQueue**，也就是说来了任务就创建线程运行，如果线程空闲超过60秒，就销毁线程。

#### 2.3 底层实现

![image-20200721095628802](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200721095628802.png)

### 3. 线程池几个重要参数介绍?

#### 3.1 七大参数：

![七大参数](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200721102048892.png)

1. **corePoolSize：**线程池中的常驻核心线程数；

- 在创建了线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程。

- 当线程池中的线程数目达到corePoolSize后，就会把到达的任务放入到缓存队列当中。

2. **maximumPoolSize**：线程池能够容纳同时执行的最大线程数，此值大于等于1；

3. **keepAliveTime**：多余的空闲线程存活时间，当空间时间达到keepAliveTime值时，多余的线程会被销毁直到只剩下corePoolSize个线程为止；

   默认情况下：只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程中的线程数不大于corepoolSize。

4. **unit**：keepAliveTime的单位；

5. **workQueue**：任务队列，被提交但尚未被执行的任务；

6. **threadFactory**：表示生成线程池中工作线程的线程工厂，用户创建新线程，一般用默认即可；

7. **handler**：拒绝策略，表示当线程队列满了并且工作线程大于等于线程池的最大显示数(maxnumPoolSize)时如何来拒绝。

#### 3.2 说说线程池的底层工作原理?

![image-20200722160202898](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200722160202898.png)


1. 在创建了线程池后，等待提交过来的任务请求。

2. 当调用 execute() 方法添加一个请求任务时，线程池会做如下判断：
   2.1 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；
   2.2 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务**放入队列**；
   2.3 如果这时候队列满了且正在运行的线程数量还小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；
   2.4 如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池**会启动饱和拒绝策略来执行**。
   
3. 当一个线程完成任务时，它会从队列中取下一个任务来执行。

4. 当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：
       如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。
   
   ​	所有线程池的所有任务完成后它**最终会收缩到 corePoolSize的大小**。

## 七、线程池用过吗?生产上你是如何设置合理参数。

### 1. 线程池的拒绝策略请你谈谈

#### 1.1 是什么

**等待队列也已经排满了**，再也塞不下新的任务了，同时，**线程池的max线程也到达了**，无法接续为新任务服务。这时我们就需要拒绝策略机制合理的处理这个问题

#### 1.2 JDK内置的拒绝策略

① AbortPolicy(默认)：直接抛出 RejectedExecutionException 异常阻止系统正常运行。

② CallerRunPolicy："调用者运行"一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。

③ DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。

④ DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种方案。

以上内置策略均实现了RejectExecutionHandler接口

![image-20200722163425615](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200722163425615.png)



### 2. 你在工作中单一的/固定数的/可变你的三种创建线程池的方法，你用哪个多？超级大坑

答案是一个都不用，我们生产上只能使用自定义的

Executors中JDK给你提供了为什么不用？

![Alibaba开发手册](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200722165003932.png)

### 3. 你在工作中是如何创建线程池的，是否自定义过线程池使用

```java
package com.aeliter.study.threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @description:
 *
 * 第四种获得/使用java多线程的方式：线程池
 *
 * @author: caibingqiang
 * @date: 2020-07-21 9:02
 * @version: V1.0
 */
public class MyThreadPoolDemo {

    public static void main(String[] args) {
        /**
         * 线程池的手写改造和拒绝策略
         */
        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                5,
                1L,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<Runnable>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardPolicy());

        // 模拟10个用户来办理业务，每个用户就是一个来自外部的请求线程
        try {
            for (int i = 1; i <= 10; i++) {
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + "\t 办理业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }

    }

    /**
     * JDK版
     */
    public static void threadPoolInit() {
        // 查看底层CPU的核数
//        System.out.println(Runtime.getRuntime().availableProcessors());

        // Array        Arrays
        // Collection   Collections
        // Executor     Executors
//        ExecutorService threadPool = Executors.newFixedThreadPool(5); // 一池5个处理线程
//        ExecutorService threadPool = Executors.newSingleThreadExecutor(); // 一池1个处理线程
        ExecutorService threadPool = Executors.newCachedThreadPool(); // 一池N个处理线程

        // 模拟10个用户来办理业务，每个用户就是一个来自外部的请求线程
        try {
            for (int i = 1; i <= 10; i++) {
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + "\t 办理业务");
                });
                // 暂停一会儿线程
                try { TimeUnit.MILLISECONDS.sleep(200); } catch(InterruptedException e) { e.printStackTrace(); }
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }

}
```



### 4. 合理配置线程池你是如何考虑的?

#### 4.1 CPU密集型

```java
System.out.println(Runtime.getRuntime().availableProcessors()); // 查看CPU核数
```

CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。
CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程），

而在单核CPU上（悲剧吧？（；¤）$），无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些。


CPU密集型任务配置尽可能少的线程数量：
一般公式：CPU核数+1个线程的线程池

#### 4.2 IO密集型

（1）由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数*2

（2）IO密集型，即该任务需要大量的IO，即大量的阻塞。
在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。
所以在IO密集型任务中使用多线程可以大大的加速程序运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。


IO密集型时，大部分线程都阻塞，故需要多配置线程数：

参考公式：CPU核数 / (1 - 阻塞系数)          阻塞系数在0.8~0.9之间

比如8核CPU：8/(1-0.9)=80个线程数

## 八、死锁编码及定位分析

### 1. 是什么

​	死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种**互相等待的现象**，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁岀现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。

![死锁](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200722205650870.png)

产生死锁的主要原因：

1. 系统资源不足
2. 进程运行推进的顺序不合适
3. 资源分配不当

### 2. 代码

```java
package com.aeliter.study.lock;

import java.util.concurrent.TimeUnit;

class HoldLockThread implements Runnable {

    private String lockA;
    private String lockB;

    public HoldLockThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized (lockA) {
            System.out.println(Thread.currentThread().getName() + "\t 自己持有：" + lockA + "\t 尝试获得：" + lockB);
            // 暂停一会儿线程
            try { TimeUnit.SECONDS.sleep(2); } catch(InterruptedException e) { e.printStackTrace(); }

            synchronized (lockB) {
                System.out.println(Thread.currentThread().getName() + "\t 自己持有：" + lockB + "\t 尝试获得：" + lockA);
            }
        }
    }
}
/**
 * @description:
 *
 * 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，
 * 若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，
 * 死锁岀现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。
 *
 * @author: caibingqiang
 * @date: 2020-07-22 17:29
 * @version: V1.0
 */
public class DeadLockDemo {

    public static void main(String[] args) {

        String lockA = "lockA";
        String lockB = "lockB";

        new Thread(new HoldLockThread(lockA, lockB), "ThreadAAA").start();
        new Thread(new HoldLockThread(lockB, lockA), "ThreadBBB").start();

    }

}
```

### 3. 解决

jps命令定位进程编号

![image-20200722205858022](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200722205858022.png)

jstack找到死锁查看

![image-20200722205907456](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200722205907456.png)

![image-20200722205914846](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200722205914846.png)

# JVM + GC解析

## 一、JM垃圾回收的时候如何确定垃圾？是否知道什么是 GC Roots？

### 1. 什么是垃圾

简单的说就是内存中已经不再被使用到的空间就是垃圾

### 2. 要进行垃圾回收，如何判断一个对象是否可以被回收

#### 2.1 引用计数法

​	Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器，每当有一个地方引用它，计数器值加1。每当有一个引用失效时，计数器值减1。任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象。那为什么主流的Java虚拟机里面都没有选用这种算法呢？其中最主要的原因是它很难解决对象之间相互循环引用的问题。

![image-20200722230159724](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200722230159724.png)

#### 2.2 枚举根节点做可达性分析（根搜索路径）

##### 2.2.1 case

![image-20200722230240756](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200722230240756.png)

##### 2.2.2 Java 可以做 GCRoots 的对象

1. 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
2. 方法区中的类静态属性引用的对象。
3. 方法区中常量引用的对象。
4. 本地方法栈中JNI（Native方法）引用的对象。

## 二、你说你做过JVM调优和参数配置，请问如何盘点查看JVM系统默认值

### 1. JVM的参数类型

1. 标配参数

![image-20200723093916674](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200723093916674.png)

2. X参数

   -Xint：解释执行

   -Xcomp：第一次使用就编译成本地代码

   -Xmixed：混合模式

![image-20200723093937259](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200723093937259.png)

3. XX参数

（1）Boolean类型

公式：-XX：+ 或者 -  某个属性值		（+ 表示开启，- 表示关闭）

case：是否打印GC收集细节（-XX：**+**PrintGCDetails， -XX：**-**PrintGCDetails）

​			是否使用串行垃圾回收器（-XX：**-**UseSerialGC， -XX：**+**UseSerialGC）

（2）KV设值类型

公式：-XX：属性key=属性值value

case：-XX：MetaspaceSize=128m（设置元空间的大小）

​			-XX：MaxTenuringThreshold=15（设置此极限年龄转入老年区）

（3）jinfo举例，如何查看当前运行程序的配置

（4）**题外话（坑题**）

两个经典参数：-Xms和-Xmx，如何解释？

其实都是XX参数：

​	-Xms：等价于 -XX:InitialHeapSize，初始化堆内存

​	-Xmx：等价于-XX:MaxHeapSize，最大堆内存



### 2. 盘点家底查看JVM默认值

1. **java -XX:+PrintFlagsInitial -version**：主要查看初始默认值
2. **java -XX:+PirntFlagsFinal -version**：主要查看修改更新
3. **java -XX:+PrintCommandLineFlags -version**：查看默认值，参数中有一项-XX:UseParallelGC

## 三、你平时工作用过的JVM常用基本配置参数有哪些?

### 1. 基础知识复习

![image-20200723230007243](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200723230007243.png)

case：

```java
long totalMemory = Runtime.getRuntime().totalMemory(); // 返回 java 虚拟机中的总量
long maxMemory = Runtime.getRuntime().maxMemory(); // 返回 java 虚拟机中试图使用的最大内存
System.out.println("TOTAL_MEMORY(-Xms) = " + totalMemory + "（字节）" + (totalMemory / (double)1024 / 1024) + "MB");
System.out.println("MAX_MEMORY(-Xmx) = " + totalMemory + "（字节）" + (maxMemory / (double)1024 / 1024) + "MB");
```

### 2. 常用参数

1. -Xms

- 初始大小内存，默认为物理内存1/64
- 等价于-XX:InitialHeapSize

2. -Xmx

- 最大分配内存，默认为物理内存1/4
- 等价于-XX:MaxHeapSize

3. -Xss

- 设置单个线程的大小，一般默认为512K~1024K
- 等价于-XX:ThreadStackSize

4. -Xmn

- 设置年轻代大小


![image-20200723230819913](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200723230819913.png)

5. -XX:MetaspaceSize

- 设置元空间大小
  - 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于： **元空间并不在虚拟机中，而是使用本地内存。** 因此，默认情况下，元空间的大小仅受本地内存的限制。
  - -Xms10m -Xmx10m -XX:MetaspaceSize=1024m -XX:+PrintFlagsFinal

6. -XX:+PrintGCDetails

- 输出详细GC收集日志信息
- GC

- FullGC

7. -XX:SurvivorRatio

- 设置新生代中eden和S0/S1空间的比例 默认 -XX:SurvivorRatio=8, Eden:S0:S1=8:1:1 假如  -XX:SurvivorRatio=4, Eden:S0:S1=4:1:1 SurvivorRatio值就是设置eden区的比例占多少，S0/S1相同


8. -XX:NewRatio

- 配置年轻代与老年代在堆结构的占比 默认 -XX:NewRatio=2新生代占1，老年代占2，年轻代占整个堆的1/3 假如 -XX:NewRatio=4新生代占1，老年代占4，年轻代占整个堆的1/5 NewRatio值就是设置老年代的占比，剩下的1给新生代

9. -XX:MaxTenuringThreshold

- 设置垃圾最大年龄

## 四、强引用、软引用、弱引用、虚引用分别是什么?

### 1. 整体架构

![整体架构](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200723233748317.png)

### 2. 强引用（默认支持模式）

当内存不足，JVM开始垃圾回收，对于强引用的对象，**就算是出现了OOM也不会对该对象进行回收，死都不收。**


强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器不会碰到这种对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，**即使该对象以后永远都不会被用到，JVM也不会回收。**因此强引用是造成Java内存泄漏的主要原因之一。

低于一个普通对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，一般认为就是可以被垃圾收集的了（当然具体回收时机还是要看垃圾回收策略）。

### 3. 软引用

软引用是一种强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。

对于只有软引用的对象来说，**当系统内存充足时，它不会被回收，当系统内存不足时，它会被回收。**

软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，**内存充足的时候就保留，不够用就回收！**

### 4. 弱引用

#### 4.1 软引用和弱引用的适用场景

加入有一个应用需要读取大量的本地图片：

- 如果每次读取图片都从硬盘则会严重影响性能；
- 如果一次性全部加载到内存中又可能造成内存溢出。

此时使用软引用可以解决这个问题：

设计思路：用一个HashMap来保存图片的路劲和相应图片对象关联的软引用之间的映射关系，当内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。

```java
Map<String, SoftReference<Bitmap>> imageCache = new HashMap<String, SoftReference<Bitmap>>();
```

####  4.2 你知道弱引用的话，能谈谈WeakHashMap吗？

![image-20200724114616484](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200724114616484.png)

运行结果：

![image-20200724114632703](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200724114632703.png)

### 5. 虚引用

在被回收之前需要被引用队列保存下。

Java提供了4种引用类型，在垃级回收的时候，都有自已各自的特点。
ReferenceQueue是用来配合引用工作的，没有 ReferenceQueue一样可以运行。
创建引用的时候可以指定关联的队列，当GC释放对象内存的时候，会将引用加入到引用队列，如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采收必要的行动，这相当于是一种**通知机制**。
当关联的引用队列中有数据的时候，意味着引用指向的堆内存中的对象被回收。通过这种方式，JVM允许我们在对象被销毁后，做一些我们自已想做的事情。

![image-20200724114710962](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200724114710962.png)

### 6. GCRoots和四大引用的小总结

![image-20200724114718319](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200724114718319.png)

## 五、请谈谈你对OOM的认识

### 1. Java.lang.StackOverflowError（Error）

![image-20200725075234742](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200725075234742.png)

### 2. Java.lang.OutOfMemoryError:Java heap space（Error）

![image-20200725075217307](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200725075217307.png)

### 3. Java.lang.OutOfMemeoryError:GC overhead limit exceeded

​		**程序在垃圾回收上花费了98%的时间，却收集不到2%的空间，通常这样的异常伴随着CPU的冲高**

![image-20200727075403334](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200727075403334.png)

```java
/**
 * @description: GC overhead limit exceeded
 *
 * JWM参数配萱演
 * -Xms10m -Xmxl0m -XX:MaxDirectMemorySize=5m 
 * GC回收时间过长时会抛出Out0fMemoryError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存，
 * 连续多次GC都只回收了不到2%的极端情况下才会抛出。假如不抛出 GC overhead limit错误会发生什么情况呢？
 * 那就是GC清理的这么点内存很快会再次填满，迫使GC再次的执行。这样就形成恶性循环，
 * CPU使用率一意是100%，GC却没有任何成果。
 *  
 * /
public class GCOverheadDemo {

    public static void main(String[] args) {
        int i = 0;
        List<String> list = new ArrayList<>();

        try {
            while (true) {
                list.add(String.valueOf(++i).intern());
            }
        } catch (Throwable e) {
            System.out.println("##########i：" + i);
            e.printStackTrace();
            throw e;
        }

    }

}
```

运行结果：

![image-20200727075500447](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200727075500447.png)

### 4. Java.lang.OutOfMemeoryError:Direct buffer memory（直接内存挂了 NIO层面）

配置参数：
-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m

```java
package com.aeliter.study.jvm.oom;

import java.nio.ByteBuffer;

/**
 * @description:
 *
 * 配置参数：
 * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m
 *
 * 故障现象：
 * Exception in thread "main" java.lang.OutOfMemory Error: Direct buffer memory
 *
 * 导致原因：
 * 写NIO程序经常使用 ByteBuffer 来读取或者写入数据，这是一种基于通道（Channel）与缓存区（Buffer）的I/O方式，它可以使用 Native 函数库
 * 直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为
 * 避免了在 Java 堆和 Native 堆中来回复制数据。
 *
 *    ByteBuffer. allocate(capability) 第一种方式是分配 JVM 堆内存，属于GC管辖范围，由于需要拷贝所以速度相较慢
 *    ByteBuffer. allocateDirect(capability) 第二种方式是分配 OS 本地内存，不属子GC管辖范围，由于不需要内存拷贝所以速度相对较快。
 *
 * 但如果不断分配本地内存，堆内存很少使用，那么 JVM 就不需要热执行GC, DirectByteBuffer象们就不会被回收，这时候堆内存充足，但本地内存可能
 * 已经使用光了，再次尝试分配本地内存就会出现0ut0fMemoryError，那程序就直接崩溃了。
 *
 * @author: caibingqiang
 * @date: 2020-07-25 10:46
 * @version: V1.0
 */
public class DirectBufferMemoryDemo {

    public static void main(String[] args) {
        System.out.println("配置的maxDirectMemory：" + (sun.misc.VM.maxDirectMemory() / (double) 1024 / 1024) + "MB");
        // 暂停一会儿线程
        try { Thread.sleep(3000); } catch(InterruptedException e) { e.printStackTrace(); }
        // -XX:MaxDirectMemorySize=5m   我们配置为5MB，但实际使用6MB，故意使坏
        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(6 * 1024 * 1024);
    }

}
```

运行结果：

![image-20200727075637487](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200727075637487.png)



### 5. Java.lang.OutOfMemeoryError:unable to create new native thread（达到了创建线程的上限）

高并发请求服务器时，经常出现如下异常：java.lang.OutOfMemoryError: unable to create new native thread，准确地讲，该 Native thread 异常与对应的平导有关。

导致原因：
    1、你的应用创建了太多线程了，一个应用进程创建多个线程，超过系统承载极限
    2、你的服务器并不允许你的应用程序创建这么多线程，linux系统默允许单个进程可以创建的线程数是1024个，你的应用创建超过这个数量，就会报java.lang.OutOfMemoryError: unable to create new native thread

解决办法：
    1、想办法降低你应用程序创建线程的数量，分析应用是否真的需要创键这么多线程，如果不是，修改代码将线程数降到最低；
    2、对于有的应用，确实需要创建很多线程，远超过linux系统的默认1024个线程的限制，可以通过修改linux服务器配置，扩大linux默认限制

```java
package com.aeliter.study.jvm.oom;

/**
 * @description:
 *
 * 高并发请求服务器时，经常出现如下异常：java.lang.OutOfMemoryError: unable to create new native thread，准确地讲，
 * 该 Native thread 异常与对应的平导有关。
 *
 * 导致原因：
 *  1、你的应用创建了太多线程了，一个应用进程创建多个线程，超过系统承载极限
 *  2、你的服务器并不允许你的应用程序创建这么多线程，linux系统默允许单个进程可以创建的线程数是1024个，你的应用创建超过这个数量，
 *     就会报java.lang.OutOfMemoryError: unable to create new native thread
 *
 * 解决办法：
 *  1、想办法降低你应用程序创建线程的数量，分析应用是否真的需要创键这么多线程，如果不是，修改代码将线程数降到最低；
 *  2、对于有的应用，确实需要创建很多线程，远超过linux系统的默认1024个线程的限制，可以通过修改linux服务器配置，扩大linux默认限制
 *
 * @author: caibingqiang
 * @date: 2020-07-25 11:09
 * @version: V1.0
 */
public class UnableCreateNewThreadDemo {

    public static void main(String[] args) {
        for (int i = 1; ; i++) {
            System.out.println("########### i = " + i);
            new Thread(() -> {
                try { Thread.sleep(Integer.MAX_VALUE); } catch(InterruptedException e) { e.printStackTrace(); }
            }, "" + i).start();
        }
    }

}
```

运行结果：

![image-20200727075800216](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200727075800216.png)

### 6. Java.lang.OutOfMemeoryError:Metaspace（元空间）

```java
package com.aeliter.study.jvm.oom;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * @description:
 *
 * JVM参数：
 * -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m
 *
 * Java8 及之后的版本使用 Metaspace 来替代水久代。
 *
 * Metaspace 是方法区在 HotSpot中的实现，它与持久代最大的区别在于：Metaspace 并不在虚拟机内存中,而是使用本地内存，也即在 Java8 中，
 * classe metadata(the virtual machines internal presentation of Java class)，被存储在叫做Metaspace 的 native memory
 * 永久代（Java8 后被元空间 Metaspace 取代了）存放了以下信息：
 *  1、虚拟机加载的类信息
 *  2、常量池
 *  3、静态变量
 *  4、即时编译后的代码
 *
 * 模拟 Metaspace空间溢出，我们不断生成类往元空间灌，类占据的空间总是会超 Metaspace指定的空间大小的
 *
 * @author: caibingqiang
 * @date: 2020-07-25 11:49
 * @version: V1.0
 */
public class MetaspaceOOMDemo {

    static class OOMTest {}
    public static void main(String[] args) {

        int i = 0;  // 模拟计数多少次以后发生异常
        try {
            while (true) {
                i++;
                Enhancer enhancer = new Enhancer();
                enhancer.setSuperclass(OOMTest.class);
                enhancer.setUseCache(false);
                enhancer.setCallback(new MethodInterceptor() {
                    @Override
                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                        return methodProxy.invokeSuper(o, args);
                    }
                });
                enhancer.create();
            }
        } catch (Throwable e) {
            System.out.println("########## 多少次后发生了异常：" + i);
            e.printStackTrace();
        }
    }

}
```

运行结果：

![image-20200727075847564](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200727075847564.png)

**使用java -XX:+PrintFlagsInitial命令查看本机的初始化参数，-XX:MetaspaceSize为21810376B(约20M)**

![image-20200727075923953](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200727075923953.png)

## 六、GC垃圾回收算法和垃圾收集器的关系？分别是什么请你谈谈

### 1. GC算法（引用计数/复制/标清/标整）是内存回收的方法论，垃圾收集器就是算法落地实现。

### 2. 因为目前为止还没有完美的收集器出现，更加没有万能的收集器，只是针对具体应用最合适的收集器，进行分代收集

### 3. 4种主要垃圾收集器

![image-20200727080101807](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200727080101807.png)

#### 3.1 串行垃圾回收器（Serial）

​	**它为单线程环境设计并且只使用一个线程进行垃圾回收，会暂停所有的用户线程。所以不适合服务器环境。**

#### 3.2 并行垃圾回收器（Parallel）

​	**多个垃圾回收线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理等弱交互场景。**

#### 3.3 并发垃圾回收器（CMS(ConcMarkSweep)）

​	**用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），不需要停顿用户线程
​	互联网公司多用它，适用于对响应时间有要求的场景**

#### 3.4 上述3个小总结，G1特殊后面说

![image-20200727080351370](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200727080351370.png)

#### 3.5 G1垃圾回收器

​	**G1垃圾回收器将堆内存分割成不同的区域，然后并发的对其进行垃圾回收**

## 七、怎么查看服务器默认的垃圾收集器是那个?生产上如何配置垃圾收集器的?谈谈你对垃圾收集器的理解?

### 1. 怎么查看默认的垃圾收集器是哪个？

JVM参数：**java -XX:+PrintCommandLineFlags -version**，下图加粗的就是默认垃圾收集器

F:\WorkSpaces\Idea Projects\Interviews>java -XX:+PrintCommandLineFlags -version
-XX:InitialHeapSize=198881536 -XX:MaxHeapSize=3182104576 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation **-XX:+UseParallelGC**
java version "1.8.0_60"
Java(TM) SE Runtime Environment (build 1.8.0_60-b27)
Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)

### 2. 默认的垃圾收集器有哪些？

Java的gc回收的类型主要有以下几种：
UseSerialGC（串行GC）, UseParallelGC（并行GC）, UseConcMarkSweepGC（并发标记清除GC）, UseParNewGC, Use ParalleloldGC, UseG1GC

看下面的代码就非常清楚：

![image-20200727083025909](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200727083025909.png)

### 3. 垃圾收集器

#### 3.1 部分参数预先说明

![image-20200727083146420](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200727083146420.png)

#### 3.2 Server/Client模式分别是什么意思？

（1）适用范围：只需要掌握Server模式即可，Client模式基本不会用

（2）操作系统：
   	① 32位的Windows操作系统，不论硬件如何都默认使用Client的JVM模式
   	② 32位其他操作系统，2G内存同时有2个CPU以上用Server模式，低于该配置还是Client模式
   	③ 64位only server模式

####  3.3 新生代

##### 3.3.1 串行GC（Serial）/（Serial Coping）（新生代一个，老年代一个）

【串行收集器：Serial收集器】
一句话：一个单线程的收集器，在进行垃圾收集的时候，必须暂停其他所有线程，直到它收集结束。

![image-20200803100350322](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200803100350322.png)

​	串行收集器是最古老、最稳定以及效率最高的收集器，只使用一个线程去回收，但其在进行垃圾收集过程中可能会产生较长的停顿STW（”Stop-The-World“状态）。虽然在收集垃圾的过程中需要暂停所有其他的工作线程，但是它简单高效，**对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是Java虚拟机运行在默认的新生代垃圾收集器。**

**对应JVM参数是：-XX:+UseSerialGC**
**开启后会使用：Serial（Young区用）+ Serial Old（Old区用）的收集器组合**
**表示：新生代、老年代都会使用串行回收收集器，新生代使用复制算法，老年代使用标记-整理算法。**

```xml
-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseSerialGC
```

##### 3.3.2 并行GC(ParNew)（新生代多个，老年代一个）

ParNew（并行）收集器
一句话：使用多线程进行垃圾回收，在垃圾收集时，会Stop-The-World暂停其他所有的工作线程直到它收集结束。

![image-20200803100525697](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200803100525697.png)

​	**ParNew收集器其实就是Serial收集器新生代的并行多线程版本，**最常见的应用场景是配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。它是很多Java虚拟机运行在Server模式下新生代的默认垃圾收集器。

**常用对于JVM参数：-XX:+UseParNewGC 启用ParNew收集器，只影响新生代的收集，不影响老年代**
**开启上述参数后，会使用：ParNew（Young区用）+ Serial Old的收集器组合，新生代使用复制算法，老年代使用标记-整理算法。**

但是，ParNew + Tenured这样的搭配，java 8下已经不再被推荐
Java Hotspot（TM）64-Bit Server VM warning:
Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed in a future release

备注:
-XX:ParalleIGCThreads 限制线程数量，默认开启和CPU数目相同的线程数

```xml
-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParNewGC
```

##### 3.3.3 并行回收GC(Parallel)/(Parallel Scavenge)（新生代多个，老年代多个）

![image-20200803100639324](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200803100639324.png)

**Parallel Scavenge收集器类似ParNew，也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器。**
**一句话：串行收集器在新生代和老年代的并行化。**

它重点关注的是：
	**可控制的吞吐量（ Thoughput=运行用户代码时间/（运行用户代码时间+垃圾收集时间），也即比如程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99%）。**
	高吞吐量意味着高效利用CPU的时间，它多用于在后台运算而不需要太多交互的任务。

自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间（-XX:MaxGCPauseMillis）或最大的吞吐量。

常用JVM参数：-XX:+UseParalleIGC或-XX:+UseParalleloldGC（可互相激活），使用 Parallel Scavenge 收集器
开启该参数后：新生代使用复制算法，老年代使用标记-整理算法

多说一句：-XX:ParallelGCThreads=数字N     表示启动多少个GC线程
   cpu>8    N=5/8
   cpu<8    N=实际个数

```xml
-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParallelGC
```

```xml
-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParallelOldGC
```

#### 3.4 老年代

##### 3.4.1 串行回收GC(Serial Old)/(Serial MSC)

​		**Serial Old是 Serial 垃圾收集器老年代版本，**它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的java虚拟机默认的年老代垃圾收集器。

在 Server 模式下，主要有两个用途（了解，版本已经到8及以后）：
1. 在JDK1.5之前版本中与新生代的 Parallel Scavenge收集器搭配使用。（ Parallel Scavenge+ Serial Old）
2. 作为老年代版中使用CMS收集器的后备垃圾收集方案

##### 3.4.2 并行GC(Parallel Old)/(Parallel MSC)

​		**Parallel Old收集器是 Parallel Scavenge 的老年代版本，使用多线程的标记-整理算法，**Parallel Old收集器在JDK1.6才开始提供。

​		在JDK 1.6之前，新生代使用 ParallelScavenge 收集器只能搭配老年代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6之前（ Parallel Scavenge + Serial Old）

​		Parallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK 1.8后可以优先考虑新生代 Parallel Scavenge 和年老代 Parallel Old 收集器的搭配策略。在JDK 1.8及后（ Parallel Scavenge + Parallel Old）

JVM常用参数：
-XX:+UseParalleloldGC 使用 Parallel Old 收集器，设置该参数后，新生代 Parallel + 老年代 Parallel Old



##### 3.4.3 并发标记清除GC(CMS)              ParNew（Young区用）+ CMS（Old区用）+ Serial Old

CMS收集器（ Concurrent Mark Sweep：并发标记清除）**是一种以获取最短回收停顿时间为目标的收集器。**
适合应用在互联网站或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，**希望系统停顿时间最短。**
CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。

![image-20200803100957928](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200803100957928.png)

**Concurrent Mark Sweep：并发标记清除，并发收集停顿低，并发指的是与用户线程一起执行。**

开启该收集器的JVM参数：-XX:+UseConcMarkSweepGC   开启该参数后会自动将 -XX:+UseParNewGC打开
开启该参数后，使用 ParNew（Young区用）+ CMS（Old区用）+ Serial Old 的收集器组合， Serial Old 将作为CMS出错的后备收集器

```xml
-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC
```

1. 四步过程

- 初始标记(CMS initial mark)

  只是标记一下GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。

- 并发标记(CMS concurrent mark)和用户线程一起

  进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象

- 重新标记(CMS remark)

  为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。

  由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正。

- 并发清除(CMS concurrent sweep)和用户线程一起

  清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。基于标记结果，直接清理对象。

  由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。

2. 优缺点

- 优

  **并发收集低停顿**

- 缺

  - 并发执行，对CPU资源压力大

    由于并发进行，CMS在收集与应用线程会同时增加对堆内存的占用，也就是说，**CMS必须要在老年代堆内存用尽之前完成垃圾回收，**否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间。

  - 采用的标记清除算法会导致大量碎片

    标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS也提供了参数-XX:CMSFullGCsBeForeCompaction（默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC。

#### 3.5 垃圾收集器配置代码总结

##### 3.5.1 底层代码

![image-20200803101724687](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200803101724687.png)

##### 3.5.2 实际代码

```java
package com.aeliter.study.jvm.gc;

import java.util.Random;

/**
 * @description:
 *
 * 1、
 * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseSerialGC          (DefNew + Tenured)
 *
 * 2、
 * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParNewGC          (ParNew + Tenured)
 *
 * 备注情况：Java Hotspot（TM）64-Bit Server VM warning:
 * Using the ParNew young collector with the Serial old collector is deprecated and
 * will likely be removed in a future release
 *
 * 3、
 * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelGC        (PSYoungGen + ParOldGen)
 *
 * 4、
 *  4.1
 *  -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelOldGC    (PSYoungGen + ParOldGen)
 *  4.2 不加就是默认UseParallelGC
 *  -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags                          (PSYoungGen + ParOldGen)
 *
 * 5、
 * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseConcMarkSweepGC   (par new generation + concurrent)
 *
 * 6、
 * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseG1GC              后面单独讲解G1
 *
 * 7、（理论知道即可，实际中 java 8 已经被优化掉了，没有了）
 * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseSerialOldGC
 * 
 * 
 * 下面是故意繁琐配置，主要是为了学习，一般生产不这么配置：
 * 下面是故意繁琐配置，主要是为了学习，一般生产不这么配置：
 * 下面是故意繁琐配置，主要是为了学习，一般生产不这么配置：
 * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelGC -XX:+UseParallelOldGC  (PSYoungGen + ParOldGen)
 * 
 * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParNewGC -XX:+UseConcMarkSweepGC  (par new generation + concurrent mark-sweep generation)
 *
 * @author: caibingqiang
 * @date: 2020-07-26 11:27
 * @version: V1.0
 */
public class GCDemo {

    public static void main(String[] args) {
        System.out.println("########## GCDemo hello!");
        try {
            String str = "Aeliter";
            while (true) {
                str += str + new Random().nextInt(77777777) + new Random().nextInt(88888888);
                str.intern();
            }
        } catch (Throwable e) {
            e.printStackTrace();
        }
    }

}
```

### 4. 如何选择垃圾收集器

![image-20200803101750515](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200803101750515.png)

![image-20200803101845636](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200803101845636.png)

## 八、G1垃圾收集器

### 1. 以前收集器的特点

- 年轻代和老年代是各自独立且连续的内存块
- 年轻代收集使用单eden+S0 +S1进行复制算法
- 老年代收集必须扫描整个老年代区域
- 都是以尽可能少而快速地执行GC为设计原则

### 2. G1是什么

G1（ Garbage-Fist）收集器，是一款面向服务端应用的收集器

![image-20200803102100295](C:\Users\10473\AppData\Roaming\Typora\typora-user-images\image-20200803102100295.png)

​		从官网的描述中，我们知道G1是一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，**在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求。**另外，它还具有以下特性：

像CMS收集器一样，能与应用程序线程并发执行。
整理空闲空间更快。
需要更多的时间来预测GC停顿时间。
不希望牺牲大量的吞吐性能。
不需要更大的 Java Heap。 

**G1收集器的设计目标是取代CMS收集器，**它同CMS相比，在以下方面表现的更出色：
G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。
G1的 Stop The World（STW）更可控，**G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。**

​		CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是它还是存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，Java 7发布了一个新的垃圾收集器-G1垃圾收集器。

​		G1是在2012年才在jdk1.7u4中可用。 oracle官方计划在jdk9中将G1变成默认的垃圾收集器以替代CMS。它是一款面向服务端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大的减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换java8以前的CMS收集器。

​		主要改变是Eden，Survivor 和 Tenured 等内存区域不再是连续的了，而是变成了一个个大小一样的 region，每个 region 从1M到32M不等。一个 region有可能属于Eden，Survivor 或者 Tenured内存区域。

特点：

1：G1能充分利用多CPU、多核环境硬件优势，尽量缩短STW。

2：G1整体上采用标记-整理算法，局部是通过复制算法，不会产生内存碎片。

3：宏观上看G1之中不再区分年轻代和老年代。把内存划分成多个独立的子区域（ Region），可以近似理解为一个围棋的棋盘

4：G1收集器里面讲整个的内存区都混合在一起了，但其本身依然在小范围内要进行年轻代和老年代的区分，保留了新生代和老年代，但它们不再是物理隔离的，而是一部分 Region 的集合且不需要 Region 是连续的，也就是说依然会采用不同的GC方式来处理不同的区域。

5：G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的 survivor（to space）堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换。

### 3. 底层原理



### 4. case案例



### 5. 常用配置参数(了解)



### 6. 和CMS相比的优势



### 7. 小总结





































































































































































